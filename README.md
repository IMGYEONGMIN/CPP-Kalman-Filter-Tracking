지금까지 공부한 KF를 실제로 구현해보고자 한다

python을 통해 가상의 데이터를 만들고 c++로 KF를 구현하고 가상의 데이터를 KF로 처리한다

그리고 다시 python을 통해 이를 시각화 하고자 한다.

코드는 깃허브를 통해 제공하며 막히는 부분들만 설명한다

<img width="444" height="109" alt="image" src="https://github.com/user-attachments/assets/33a6b379-d93d-4ec5-aa54-6ccdd9b300b5" />

위 식은 $p_k​=p_{k−1}​+v_{k−1}​Δt+\frac{1}{2}​a_k​Δt^2$을 x축,y축으로 구현한 것이다.

이때 $\frac{1}{2}​a_k​Δt^2$은 가속 때문에 생긴 추가 이동거리이다

만약 가속이 일정하다면

- 시작 속도: $v_{k-1}$
- 끝 속도: $v_{k−1}+aΔt$
- 평균 속도
<img width="1014" height="360" alt="image" src="https://github.com/user-attachments/assets/d28ce593-2c84-4f97-b9d6-b8fb5debd8ab" />


<img width="1083" height="738" alt="image" src="https://github.com/user-attachments/assets/fa40a9b0-2c42-48a7-a9e5-24a2171e7324" />

<img width="1145" height="747" alt="image" src="https://github.com/user-attachments/assets/cb0604f4-94c0-4253-9544-f08d2430927d" />

## **프로젝트 명: C++ 기반 실시간 칼만 필터(KF) 추적 시스템**

**1. 프로젝트 개요 (Overview)**
• **한줄 요약:** Python으로 검증된 칼만 필터 알고리즘을 C++로 포팅(Porting)하여 실시간성을 확보하고, GPS 음영 구역(터널)에서도 객체를 추적할 수 있는 **강건한(Robust) 추적 시스템** 개발
• **개발 기간:** 2026.02.14 ~ 2026.02.16 (3일)
• **사용 기술:**
    ◦ **Language:** C++ (Core Logic), Python (Prototyping & Visualization)
    ◦ **Library:** Eigen (Linear Algebra), Matplotlib
    ◦ **Tools:** Visual Studio ,Colab

**2. 핵심 문제 해결 (Key Achievements)**
이 프로젝트에서 **단순 구현이 아니라 "엔지니어링 문제"를 어떻게 해결했는지**가 포인트입니다.

 **1. Python → C++ 포팅 및 정밀도 검증**
• **문제:** Python은 연구용으로는 좋으나 임베디드/실시간 시스템에는 부적합.
• **해결:** C++ `Eigen` 라이브러리를 활용해 알고리즘을 이식.
• **성과:** Python 프로토타입과 C++ 결과값 오차를 $10^{-13}$ **이하**로 줄여 정밀도(Precision)를 검증함.

 **2. 메모리 효율적인 스트리밍(Streaming) 구조 구현**
• **문제:** 초기 구현(Batch)은 모든 데이터를 메모리(`std::vector`)에 올리는 방식이라, 장시간 구동 시 메모리 부족 위험(O(N)) 존재.
• **해결:** 데이터를 한 줄씩 읽어 처리하고 즉시 폐기하는 **스트리밍(Streaming) 구조**로 변경.
• **성과:** 데이터 양이 무한대로 늘어나도 메모리 사용량은 일정(O(1))하게 유지되는 실시간 시스템 구조 확립.

**3. 수치적 안정성(Numerical Stability) 확보**
• **문제:** 역행렬(`inverse()`) 연산은 계산 비용이 높고, 특이 행렬(Singular Matrix)일 경우 치명적인 오류 발생 가능.
• **해결:** 역행렬을 직접 구하지 않고 **Cholesky 분해(`ldlt().solve()`)** 방식을 적용.
• **성과:** 연산 속도 향상 및 부동소수점 오차에 강한(Robust) 수치 연산 구현.

**4. 터널 시뮬레이션 (Prediction Only Mode)**
• **시나리오:** GPS 수신이 불가능한 터널 구간(50초간 데이터 소실) 가정.
• **구현:** 측정값 Update를 중단하고, **Predict(예측)** 단계만 수행하여 관성 항법(Dead Reckoning) 구현.
• **결과:** 센서 데이터가 끊겨도 기존 속도 벡터를 유지하며 경로를 추정, 터널 탈출 직후 센서 데이터와 빠르게 재수렴(Recovery)하는 성능 확인.


<img width="1535" height="824" alt="image" src="https://github.com/user-attachments/assets/484d0dca-d232-4947-b113-4dd23dbd77c8" />



<img width="1335" height="665" alt="image" src="https://github.com/user-attachments/assets/4c326b0b-81e6-41fc-976d-4747f9e81bf0" />


- **빨간 점:** 노이즈가 섞인 센서 데이터 (터널 내에서도 잡음이 발생한다고 가정)

- **파란 선:** 칼만 필터 추정 경로. 터널 구간(회색)에서는 센서 값을 무시하고 예측만으로 부드러운 직선 주행을 수행함.

**1. "관성의 법칙" (노란색/파란색 직선 구간)**
회색 영역(터널)에서 파란 선이 **자로 잰 듯이 일직선**으로 뻗어나가는 게 보이시나요?
• 센서 데이터(빨간 점)가 없어도, 칼만 필터는 **"아까 그 속도($v$) 그대로 가고 있겠지?"** 하고 추측 비행(Dead Reckoning)을 한 것입니다.
• 이게 바로 단순한 평균 필터(Average Filter)는 절대 못 하는, 칼만 필터만의 **"예측(Predict)" 능력**입니다.
**2. "드리프트(Drift)" 현상 (직선과 빨간 점의 차이)**
터널 끝부분을 자세히 보세요. 파란 선(예측)과 빨간 점(실제 측정값) 사이의 거리가 점점 벌어지죠?
• 세상에 완벽한 예측은 없습니다. 시간이 지날수록 추정 오차가 눈덩이처럼 불어납니다.
• "만약 터널이 10분 동안 이어졌다면?" -> 저 파란 선은 실제 위치랑 완전히 딴판인 곳을 가리키고 있었을 겁니다. (이래서 GPS가 끊기면 내비게이션이 엉뚱한 길로 가는 겁니다.)
**3. "재수렴(Recovery)" (터널 끝나자마자 꺾이는 부분)**
회색 영역이 끝나는 순간(k=151), 파란 선이 **수직으로 확 꺾여서** 빨간 점을 따라잡는 게 보이시나요?
• 터널을 나오자마자 센서 데이터가 `탁` 들어오니, 필터가 **"아차! 내가 예측한 게 틀렸구나!"** 하고 순식간에 위치를 수정한 겁니다.
• 이때 내부적으로 $P$(불확실성) 행렬이 엄청 컸기 때문에, **"내 예측보다 센서 값을 더 믿어야겠다"**고 판단해서 급격하게 붙은 겁니다.
